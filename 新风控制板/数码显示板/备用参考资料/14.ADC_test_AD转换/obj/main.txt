; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\main.o --depend=.\obj\main.d --device=DARMSTM --apcs=interwork -O3 -I..\..\library\inc -I..\..\library\src -I..\uvsion -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\obj\main.crf main.c]
                          THUMB

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;213    *******************************************************************************/
;;;214    void GPIO_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;215    {
;;;216      GPIO_InitTypeDef GPIO_InitStructure;
;;;217    
;;;218      /* Configure PC.04 (ADC Channel14) as analog input -------------------------*/
;;;219      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
000002  2010              MOVS     r0,#0x10
000004  f8ad0000          STRH     r0,[sp,#0]
;;;220      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000008  2000              MOVS     r0,#0
00000a  f88d0003          STRB     r0,[sp,#3]
;;;221      GPIO_Init(GPIOC, &GPIO_InitStructure);
00000e  4669              MOV      r1,sp
000010  480e              LDR      r0,|L1.76|
000012  f7fffffe          BL       GPIO_Init
;;;222    
;;;223       /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;224      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000016  f44f7000          MOV      r0,#0x200
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;225      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2018              MOVS     r0,#0x18
000020  f88d0003          STRB     r0,[sp,#3]
;;;226      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
;;;227      GPIO_Init(GPIOA, &GPIO_InitStructure);
000026  4c0a              LDR      r4,|L1.80|
000028  f88d0002          STRB     r0,[sp,#2]            ;226
00002c  4669              MOV      r1,sp
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_Init
;;;228        
;;;229      /* Configure USART1 Rx (PA.10) as input floating */
;;;230      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000034  1520              ASRS     r0,r4,#20
000036  f8ad0000          STRH     r0,[sp,#0]
;;;231      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  2004              MOVS     r0,#4
00003c  f88d0003          STRB     r0,[sp,#3]
;;;232      GPIO_Init(GPIOA, &GPIO_InitStructure);
000040  4669              MOV      r1,sp
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       GPIO_Init
;;;233    
;;;234    }
000048  bd38              POP      {r3-r5,pc}
;;;235    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      0x40011000
                  |L1.80|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;242    *******************************************************************************/
;;;243    void NVIC_Configuration(void)
000000  2100              MOVS     r1,#0
;;;244    {
;;;245    #ifdef  VECT_TAB_RAM  
;;;246      /* Set the Vector Table base location at 0x20000000 */ 
;;;247      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;248    #else  /* VECT_TAB_FLASH  */
;;;249      /* Set the Vector Table base location at 0x08000000 */ 
;;;250      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  f04f6000          MOV      r0,#0x8000000
000006  f7ffbffe          B.W      NVIC_SetVectorTable
;;;251    #endif
;;;252    }
;;;253    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;145    *******************************************************************************/
;;;146    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;147    {
;;;148      /* RCC system reset(for debug purpose) */
;;;149      RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;150    
;;;151      /* Enable HSE */
;;;152      RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3480          MOV      r4,#0x10000
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_HSEConfig
;;;153    
;;;154      /* Wait till HSE is ready */
;;;155      HSEStartUpStatus = RCC_WaitForHSEStartUp();
000010  f7fffffe          BL       RCC_WaitForHSEStartUp
000014  491d              LDR      r1,|L3.140|
000016  7048              STRB     r0,[r1,#1]
;;;156    
;;;157      if(HSEStartUpStatus == SUCCESS)
000018  b2c0              UXTB     r0,r0
00001a  2801              CMP      r0,#1
00001c  d126              BNE      |L3.108|
;;;158      {
;;;159        /* HCLK = SYSCLK */
;;;160        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_HCLKConfig
;;;161      
;;;162        /* PCLK2 = HCLK */
;;;163        RCC_PCLK2Config(RCC_HCLK_Div1); 
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RCC_PCLK2Config
;;;164    
;;;165        /* PCLK1 = HCLK/2 */
;;;166        RCC_PCLK1Config(RCC_HCLK_Div2);
00002a  11a0              ASRS     r0,r4,#6
00002c  f7fffffe          BL       RCC_PCLK1Config
;;;167    
;;;168        /* ADCCLK = PCLK2/4 */
;;;169        RCC_ADCCLKConfig(RCC_PCLK2_Div4); 
000030  10a0              ASRS     r0,r4,#2
000032  f7fffffe          BL       RCC_ADCCLKConfig
;;;170      
;;;171        /* Flash 2 wait state */
;;;172        FLASH_SetLatency(FLASH_Latency_2);
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       FLASH_SetLatency
;;;173        /* Enable Prefetch Buffer */
;;;174        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00003c  2010              MOVS     r0,#0x10
00003e  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;175    
;;;176        /* PLLCLK = 8MHz * 9 = 56 MHz */
;;;177        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000042  f44f11e0          MOV      r1,#0x1c0000
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       RCC_PLLConfig
;;;178    
;;;179        /* Enable PLL */ 
;;;180        RCC_PLLCmd(ENABLE);
00004c  2001              MOVS     r0,#1
00004e  f7fffffe          BL       RCC_PLLCmd
                  |L3.82|
;;;181    
;;;182        /* Wait till PLL is ready */
;;;183        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000052  2039              MOVS     r0,#0x39
000054  f7fffffe          BL       RCC_GetFlagStatus
000058  2800              CMP      r0,#0
00005a  d0fa              BEQ      |L3.82|
;;;184        {
;;;185        }
;;;186    
;;;187        /* Select PLL as system clock source */
;;;188        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00005c  2002              MOVS     r0,#2
00005e  f7fffffe          BL       RCC_SYSCLKConfig
;;;189    
;;;190        /* Wait till PLL is used as system clock source */
;;;191        while(RCC_GetSYSCLKSource() != 0x08)
000062  bf00              NOP      
                  |L3.100|
000064  f7fffffe          BL       RCC_GetSYSCLKSource
000068  2808              CMP      r0,#8
00006a  d1fb              BNE      |L3.100|
                  |L3.108|
;;;192        {
;;;193        }
;;;194      }
;;;195    
;;;196    /* Enable peripheral clocks --------------------------------------------------*/
;;;197      /* Enable DMA clock */
;;;198      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  4608              MOV      r0,r1
000070  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;199    
;;;200      /* Enable ADC1 and GPIOC clock */
;;;201      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC, ENABLE);
000074  2101              MOVS     r1,#1
000076  f44f7004          MOV      r0,#0x210
00007a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;202    
;;;203      /* Enable USART1 and GPIOA clock */
;;;204      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
00007e  e8bd4010          POP      {r4,lr}
000082  2101              MOVS     r1,#1
000084  f2440004          MOV      r0,#0x4004
000088  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;205    }
;;;206    
                          ENDP

                  |L3.140|
                          DCD      ||.data||

                          AREA ||i.USART_Configuration1||, CODE, READONLY, ALIGN=2

                  USART_Configuration1 PROC
;;;281    *******************************************************************************/
;;;282    void USART_Configuration1(void)
000000  b530              PUSH     {r4,r5,lr}
;;;283    {
000002  b087              SUB      sp,sp,#0x1c
;;;284      USART_InitTypeDef USART_InitStructure;
;;;285      USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;286    /* USART1 configuration ------------------------------------------------------*/
;;;287      /* USART1 configured as follow:
;;;288            - BaudRate = 19200 baud  
;;;289            - Word Length = 8 Bits
;;;290            - One Stop Bit
;;;291            - No parity
;;;292            - Hardware flow control disabled (RTS and CTS signals)
;;;293            - Receive and transmit enabled
;;;294            - USART Clock disabled
;;;295            - USART CPOL: Clock is active low
;;;296            - USART CPHA: Data is captured on the middle 
;;;297            - USART LastBit: The clock pulse of the last data bit is not output to 
;;;298                             the SCLK pin
;;;299      */
;;;300      USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000004  2400              MOVS     r4,#0
;;;301    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
;;;302    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000006  f44f7000          MOV      r0,#0x200
00000a  f8ad0008          STRH     r0,[sp,#8]
;;;303    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
;;;304    /* Configure the USART1 synchronous paramters */
;;;305    USART_ClockInit(USART1, &USART_ClockInitStructure);
00000e  4d11              LDR      r5,|L4.84|
000010  f8ad4004          STRH     r4,[sp,#4]            ;300
000014  f8ad4006          STRH     r4,[sp,#6]            ;301
000018  f8ad400a          STRH     r4,[sp,#0xa]          ;303
00001c  a901              ADD      r1,sp,#4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_ClockInit
;;;306    
;;;307    USART_InitStructure.USART_BaudRate = 19200;
000024  f44f4096          MOV      r0,#0x4b00
;;;308    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000028  9003              STR      r0,[sp,#0xc]
;;;309    USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;310    USART_InitStructure.USART_Parity = USART_Parity_No ;
00002a  f8ad4014          STRH     r4,[sp,#0x14]
;;;311    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;312    
;;;313    
;;;314    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00002e  200c              MOVS     r0,#0xc
000030  f8ad4010          STRH     r4,[sp,#0x10]         ;308
000034  f8ad0016          STRH     r0,[sp,#0x16]
000038  f8ad4012          STRH     r4,[sp,#0x12]         ;309
00003c  f8ad4018          STRH     r4,[sp,#0x18]         ;311
;;;315    /* Configure USART1 basic and asynchronous paramters */
;;;316    USART_Init(USART1, &USART_InitStructure);
000040  a903              ADD      r1,sp,#0xc
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       USART_Init
;;;317      /* Enable USART1 */
;;;318      USART_Cmd(USART1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       USART_Cmd
;;;319    }
000050  b007              ADD      sp,sp,#0x1c
000052  bd30              POP      {r4,r5,pc}
;;;320     
                          ENDP

                  |L4.84|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;328    
;;;329    int fputc(int ch, FILE *f)
000000  b510              PUSH     {r4,lr}
;;;330    {
000002  4604              MOV      r4,r0
;;;331    #ifdef DBG_ITM
;;;332    /* 将Printf内容发往ITM激励寄存器端口  */
;;;333      if (DEMCR & TRCENA) {
;;;334        while (ITM_Port32(0) == 0);
;;;335        ITM_Port8(0) = ch;
;;;336      }
;;;337    #else  
;;;338    /* 将Printf内容发往串口 */
;;;339      USART_SendData(USART1, (unsigned char) ch);
000004  b2c1              UXTB     r1,r0
000006  4805              LDR      r0,|L5.28|
000008  f7fffffe          BL       USART_SendData
;;;340      while (!(USART1->SR & USART_FLAG_TXE));
00000c  4804              LDR      r0,|L5.32|
00000e  bf00              NOP      
                  |L5.16|
000010  f8b01800          LDRH     r1,[r0,#0x800]
000014  0609              LSLS     r1,r1,#24
000016  d5fb              BPL      |L5.16|
;;;341    #endif  
;;;342      return (ch);
000018  4620              MOV      r0,r4
;;;343    }
00001a  bd10              POP      {r4,pc}
;;;344    
                          ENDP

                  |L5.28|
                          DCD      0x40013800
                  |L5.32|
                          DCD      0x40013000

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;52     *******************************************************************************/
;;;53     int main(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;54     {
;;;55     #ifdef DEBUG
;;;56       debug();
;;;57     #endif
;;;58     
;;;59       /* System clocks configuration ---------------------------------------------*/
;;;60       RCC_Configuration();
000004  f7fffffe          BL       RCC_Configuration
;;;61     
;;;62       /* NVIC configuration ------------------------------------------------------*/
;;;63       NVIC_Configuration();
000008  f7fffffe          BL       NVIC_Configuration
;;;64     
;;;65       /* GPIO configuration ------------------------------------------------------*/
;;;66       GPIO_Configuration();
00000c  f7fffffe          BL       GPIO_Configuration
;;;67        
;;;68        /* Configure the USART1 */
;;;69       USART_Configuration1();
000010  f7fffffe          BL       USART_Configuration1
;;;70     
;;;71       printf("\r\n USART1 print AD_value -------------------------- \r\n"); 
000014  a036              ADR      r0,|L6.240|
000016  f7fffffe          BL       __2printf
;;;72     
;;;73       /* DMA channel1 configuration ----------------------------------------------*/
;;;74       DMA_DeInit(DMA1_Channel1);
00001a  4d43              LDR      r5,|L6.296|
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       DMA_DeInit
;;;75       DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
000022  4843              LDR      r0,|L6.304|
000024  4941              LDR      r1,|L6.300|
;;;76       DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue;
000026  6001              STR      r1,[r0,#0]  ; DMA_InitStructure
000028  4942              LDR      r1,|L6.308|
;;;77       DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
00002a  2400              MOVS     r4,#0
;;;78       DMA_InitStructure.DMA_BufferSize = 1;
00002c  2601              MOVS     r6,#1
;;;79       DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00002e  1d02              ADDS     r2,r0,#4
000030  c252              STM      r2!,{r1,r4,r6}
;;;80       DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
000032  6104              STR      r4,[r0,#0x10]  ; DMA_InitStructure
;;;81       DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
000034  15a9              ASRS     r1,r5,#22
;;;82       DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000036  e9c04105          STRD     r4,r1,[r0,#0x14]
00003a  0089              LSLS     r1,r1,#2
;;;83       DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
00003c  61c1              STR      r1,[r0,#0x1c]  ; DMA_InitStructure
00003e  2120              MOVS     r1,#0x20
;;;84       DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000040  6201              STR      r1,[r0,#0x20]  ; DMA_InitStructure
000042  0209              LSLS     r1,r1,#8
;;;85       DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
;;;86       DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000044  e9c01409          STRD     r1,r4,[r0,#0x24]
000048  4601              MOV      r1,r0
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       DMA_Init
;;;87       
;;;88       /* Enable DMA channel1 */
;;;89       DMA_Cmd(DMA1_Channel1, ENABLE);
000050  2101              MOVS     r1,#1
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       DMA_Cmd
;;;90          
;;;91       /* ADC1 configuration ------------------------------------------------------*/
;;;92       ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000058  4835              LDR      r0,|L6.304|
;;;93       ADC_InitStructure.ADC_ScanConvMode = ENABLE;
;;;94       ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
;;;95       ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00005a  f44f2160          MOV      r1,#0xe0000
00005e  3814              SUBS     r0,r0,#0x14           ;92
000060  6004              STR      r4,[r0,#0]            ;93  ; ADC_InitStructure
000062  7106              STRB     r6,[r0,#4]            ;93
000064  7146              STRB     r6,[r0,#5]            ;94
;;;96       ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
;;;97       ADC_InitStructure.ADC_NbrOfChannel = 1;
000066  e9c01402          STRD     r1,r4,[r0,#8]
;;;98       ADC_Init(ADC1, &ADC_InitStructure);
00006a  4d30              LDR      r5,|L6.300|
00006c  7406              STRB     r6,[r0,#0x10]         ;97
00006e  4601              MOV      r1,r0
000070  3d4c              SUBS     r5,r5,#0x4c
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       ADC_Init
;;;99     
;;;100      /* ADC1 regular channel14 configuration */ 
;;;101      ADC_RegularChannelConfig(ADC1, ADC_Channel_14, 1, ADC_SampleTime_55Cycles5);
000078  2305              MOVS     r3,#5
00007a  2201              MOVS     r2,#1
00007c  210e              MOVS     r1,#0xe
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       ADC_RegularChannelConfig
;;;102    
;;;103      /* Enable ADC1 DMA */
;;;104      ADC_DMACmd(ADC1, ENABLE);
000084  2101              MOVS     r1,#1
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       ADC_DMACmd
;;;105      
;;;106      /* Enable ADC1 */
;;;107      ADC_Cmd(ADC1, ENABLE);
00008c  2101              MOVS     r1,#1
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       ADC_Cmd
;;;108    
;;;109      /* Enable ADC1 reset calibaration register */   
;;;110      ADC_ResetCalibration(ADC1);
000094  4628              MOV      r0,r5
000096  f7fffffe          BL       ADC_ResetCalibration
                  |L6.154|
;;;111      /* Check the end of ADC1 reset calibration register */
;;;112      while(ADC_GetResetCalibrationStatus(ADC1));
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000a0  2800              CMP      r0,#0
0000a2  d1fa              BNE      |L6.154|
;;;113    
;;;114      /* Start ADC1 calibaration */
;;;115      ADC_StartCalibration(ADC1);
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       ADC_StartCalibration
                  |L6.170|
;;;116      /* Check the end of ADC1 calibration */
;;;117      while(ADC_GetCalibrationStatus(ADC1));
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       ADC_GetCalibrationStatus
0000b0  2800              CMP      r0,#0
0000b2  d1fa              BNE      |L6.170|
;;;118         
;;;119      /* Start ADC1 Software Conversion */ 
;;;120      ADC_SoftwareStartConvCmd(ADC1, ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  4628              MOV      r0,r5
0000b8  f7fffffe          BL       ADC_SoftwareStartConvCmd
0000bc  46a8              MOV      r8,r5                 ;98
;;;121    
;;;122     while(1)
;;;123      {
;;;124      AD_value=ADC_GetConversionValue(ADC1);
0000be  4f1d              LDR      r7,|L6.308|
;;;125       if (ticks++ >= 900000) {                  /* Set Clock1s to 1 every 1 second    */
0000c0  4d1d              LDR      r5,|L6.312|
0000c2  1ebf              SUBS     r7,r7,#2              ;124
                  |L6.196|
0000c4  4640              MOV      r0,r8                 ;124
0000c6  f7fffffe          BL       ADC_GetConversionValue
0000ca  6078              STR      r0,[r7,#4]  ; AD_value
0000cc  68ba              LDR      r2,[r7,#8]  ; ticks
0000ce  1c51              ADDS     r1,r2,#1
0000d0  60b9              STR      r1,[r7,#8]  ; ticks
0000d2  42aa              CMP      r2,r5
0000d4  d302              BCC      |L6.220|
;;;126        ticks   = 0;
;;;127        Clock1s = 1;
0000d6  60bc              STR      r4,[r7,#8]  ; ticks
0000d8  703e              STRB     r6,[r7,#0]
0000da  e002              B        |L6.226|
                  |L6.220|
;;;128      }
;;;129    
;;;130       /* Printf message with AD value to serial port every 1 second             */
;;;131        if (Clock1s) {
0000dc  7839              LDRB     r1,[r7,#0]  ; Clock1s
0000de  2900              CMP      r1,#0
0000e0  d0f0              BEQ      |L6.196|
                  |L6.226|
;;;132          Clock1s = 0;
0000e2  4601              MOV      r1,r0
0000e4  703c              STRB     r4,[r7,#0]
;;;133          printf("The current AD value = 0x%04X \r\n", AD_value);
0000e6  a015              ADR      r0,|L6.316|
0000e8  f7fffffe          BL       __2printf
0000ec  e7ea              B        |L6.196|
;;;134        }
;;;135      
;;;136      }
;;;137    }
;;;138    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L6.240|
0000f0  0d0a20555341525431207072696e742041445f76616c7565202d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d200d        DCB      "\r\n USART1 print AD_value -------------------------- \r"
000125  0a00              DCB      "\n",0
000127  00                DCB      0
                  |L6.296|
                          DCD      0x40020008
                  |L6.300|
                          DCD      0x4001244c
                  |L6.304|
                          DCD      ||.bss||+0x14
                  |L6.308|
                          DCD      ||.data||+0x2
                  |L6.312|
                          DCD      0x000dbba0
                  |L6.316|
00013c  5468652063757272656e742041442076616c7565203d20307825303458200d0a00        DCB      "The current AD value = 0x%04X \r\n",0
00015d  00                DCB      0
00015e  00                DCB      0
00015f  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ADC_InitStructure
                          %        20
                  DMA_InitStructure
                          %        44

                          AREA ||.data||, DATA, ALIGN=2

                  Clock1s
000000  00                DCB      0x00
                  HSEStartUpStatus
000001  00                DCB      0x00
                  ADC_ConvertedValue
000002  0000              DCB      0x00,0x00
                  AD_value
                          DCD      0x00000000
                  ticks
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
