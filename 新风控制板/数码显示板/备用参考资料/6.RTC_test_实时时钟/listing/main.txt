; generated by ARM C/C++ Compiler, 4.1 [Build 713]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\main.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\output\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\ -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\output\main.crf main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Time_Display PROC
;;;364    *******************************************************************************/
;;;365    void Time_Display(u32 TimeVar)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;366    { 
000004  4604              MOV      r4,r0
;;;367      u32 THH = 0, TMM = 0, TSS = 0;
000006  f04f0500          MOV      r5,#0
00000a  462e              MOV      r6,r5
00000c  462f              MOV      r7,r5
;;;368    
;;;369      /* Compute  hours */
;;;370      THH = TimeVar/3600;
00000e  f44f6061          MOV      r0,#0xe10
000012  fbb4f5f0          UDIV     r5,r4,r0
;;;371      /* Compute minutes */
;;;372      TMM = (TimeVar % 3600)/60;
000016  fbb4f1f0          UDIV     r1,r4,r0
00001a  fb004011          MLS      r0,r0,r1,r4
00001e  f04f013c          MOV      r1,#0x3c
000022  fbb0f6f1          UDIV     r6,r0,r1
;;;373      /* Compute seconds */
;;;374      TSS = (TimeVar % 3600)% 60;
000026  f44f6061          MOV      r0,#0xe10
00002a  fbb4f1f0          UDIV     r1,r4,r0
00002e  fb004011          MLS      r0,r0,r1,r4
000032  f04f013c          MOV      r1,#0x3c
000036  fbb0f2f1          UDIV     r2,r0,r1
00003a  fb010712          MLS      r7,r1,r2,r0
;;;375    
;;;376      printf("Time: %0.2d:%0.2d:%0.2d\r",THH, TMM, TSS);
00003e  463b              MOV      r3,r7
000040  4632              MOV      r2,r6
000042  4629              MOV      r1,r5
000044  a0df              ADR      r0,|L1.964|
000046  f7fffffe          BL       __2printf
;;;377    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;378    
                          ENDP

                  Time_Show PROC
;;;385    ******************************************************************************/
;;;386    void Time_Show(void)
00004e  a0e4              ADR      r0,|L1.992|
;;;387    {
;;;388      printf("\n\r");
000050  f7fffffe          BL       __2printf
;;;389      
;;;390      /* Infinite loop */ 
;;;391      while(1)
000054  e00c              B        |L1.112|
                  |L1.86|
;;;392      {
;;;393        /* If 1s has paased */
;;;394        if(TimeDisplay == 1)
000056  48e3              LDR      r0,|L1.996|
000058  6800              LDR      r0,[r0,#0]  ; TimeDisplay
00005a  2801              CMP      r0,#1
00005c  d108              BNE      |L1.112|
;;;395        {    
;;;396          /* Display current time */
;;;397          Time_Display(RTC_GetCounter());
00005e  f7fffffe          BL       RTC_GetCounter
000062  4604              MOV      r4,r0
000064  f7fffffe          BL       Time_Display
;;;398          TimeDisplay = 0;
000068  f04f0000          MOV      r0,#0
00006c  49dd              LDR      r1,|L1.996|
00006e  6008              STR      r0,[r1,#0]  ; TimeDisplay
                  |L1.112|
000070  e7f1              B        |L1.86|
;;;399        }
;;;400      }
;;;401    }
;;;402    
                          ENDP

                  USART_Scanf PROC
;;;487    *******************************************************************************/
;;;488    u8 USART_Scanf(u32 value)
000072  b57c              PUSH     {r2-r6,lr}
;;;489    {
000074  4605              MOV      r5,r0
;;;490      u32 index = 0;
000076  f04f0400          MOV      r4,#0
;;;491      u32 tmp[2] = {0, 0};     
00007a  4620              MOV      r0,r4
00007c  9000              STR      r0,[sp,#0]
00007e  9001              STR      r0,[sp,#4]
;;;492      
;;;493      while(index < 2)
000080  e01e              B        |L1.192|
                  |L1.130|
;;;494      {
;;;495        /* Loop until RXNE = 1 */
;;;496        while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
000082  bf00              NOP      
                  |L1.132|
000084  2120              MOVS     r1,#0x20
000086  48d8              LDR      r0,|L1.1000|
000088  f7fffffe          BL       USART_GetFlagStatus
00008c  2800              CMP      r0,#0
00008e  d0f9              BEQ      |L1.132|
;;;497        {
;;;498        }
;;;499        tmp[index++] = (USART_ReceiveData(USART1));
000090  48d5              LDR      r0,|L1.1000|
000092  f7fffffe          BL       USART_ReceiveData
000096  4621              MOV      r1,r4
000098  f1040401          ADD      r4,r4,#1
00009c  f84d0021          STR      r0,[sp,r1,LSL #2]
;;;500        if((tmp[index - 1] < 0x30) || (tmp[index - 1] > 0x39))
0000a0  f1a40001          SUB      r0,r4,#1
0000a4  f85d0020          LDR      r0,[sp,r0,LSL #2]
0000a8  2830              CMP      r0,#0x30
0000aa  d304              BCC      |L1.182|
0000ac  1e60              SUBS     r0,r4,#1
0000ae  f85d0020          LDR      r0,[sp,r0,LSL #2]
0000b2  2839              CMP      r0,#0x39
0000b4  d904              BLS      |L1.192|
                  |L1.182|
;;;501        {
;;;502          printf("\n\rPlease enter valid number between 0 and 9");
0000b6  a0cd              ADR      r0,|L1.1004|
0000b8  f7fffffe          BL       __2printf
;;;503          index--;
0000bc  f1a40401          SUB      r4,r4,#1
                  |L1.192|
0000c0  2c02              CMP      r4,#2                 ;493
0000c2  d3de              BCC      |L1.130|
;;;504        }
;;;505      }
;;;506      /* Calculate the Corresponding value */
;;;507      index = (tmp[1] - 0x30) + ((tmp[0] - 0x30) * 10); 
0000c4  9801              LDR      r0,[sp,#4]
0000c6  f1a00030          SUB      r0,r0,#0x30
0000ca  9900              LDR      r1,[sp,#0]
0000cc  f1a10130          SUB      r1,r1,#0x30
0000d0  eb010181          ADD      r1,r1,r1,LSL #2
0000d4  eb000441          ADD      r4,r0,r1,LSL #1
;;;508      /* Checks */
;;;509      if(index > value)
0000d8  42ac              CMP      r4,r5
0000da  d905              BLS      |L1.232|
;;;510      {
;;;511        printf("\n\rPlease enter valid number between 0 and %d", value);
0000dc  4629              MOV      r1,r5
0000de  a0ce              ADR      r0,|L1.1048|
0000e0  f7fffffe          BL       __2printf
;;;512        return 0xFF;
0000e4  20ff              MOVS     r0,#0xff
                  |L1.230|
;;;513      }
;;;514      return index;
;;;515    }
0000e6  bd7c              POP      {r2-r6,pc}
                  |L1.232|
0000e8  b2e0              UXTB     r0,r4                 ;514
0000ea  e7fc              B        |L1.230|
;;;516    
                          ENDP

                  Time_Regulate PROC
;;;311    *******************************************************************************/
;;;312    u32 Time_Regulate(void)
0000ec  b570              PUSH     {r4-r6,lr}
;;;313    {
;;;314      u32 Tmp_HH = 0xFF, Tmp_MM = 0xFF, Tmp_SS = 0xFF;
0000ee  f04f06ff          MOV      r6,#0xff
0000f2  4634              MOV      r4,r6
0000f4  4625              MOV      r5,r4
;;;315    
;;;316      printf("\r\n==============Time Settings=====================================");
0000f6  48d4              LDR      r0,|L1.1096|
0000f8  f7fffffe          BL       __2printf
;;;317      printf("\r\n  Please Set Hours");
0000fc  a0d3              ADR      r0,|L1.1100|
0000fe  f7fffffe          BL       __2printf
;;;318      
;;;319      while(Tmp_HH == 0xFF)
000102  e003              B        |L1.268|
                  |L1.260|
;;;320      {
;;;321        Tmp_HH = USART_Scanf(23);
000104  2017              MOVS     r0,#0x17
000106  f7fffffe          BL       USART_Scanf
00010a  4606              MOV      r6,r0
                  |L1.268|
00010c  2eff              CMP      r6,#0xff              ;319
00010e  d0f9              BEQ      |L1.260|
;;;322      }
;;;323      printf(":  %d", Tmp_HH); 
000110  4631              MOV      r1,r6
000112  a0d4              ADR      r0,|L1.1124|
000114  f7fffffe          BL       __2printf
;;;324      printf("\r\n  Please Set Minutes");
000118  a0d4              ADR      r0,|L1.1132|
00011a  f7fffffe          BL       __2printf
;;;325      while(Tmp_MM == 0xFF)
00011e  e003              B        |L1.296|
                  |L1.288|
;;;326      {
;;;327        Tmp_MM = USART_Scanf(59);
000120  203b              MOVS     r0,#0x3b
000122  f7fffffe          BL       USART_Scanf
000126  4604              MOV      r4,r0
                  |L1.296|
000128  2cff              CMP      r4,#0xff              ;325
00012a  d0f9              BEQ      |L1.288|
;;;328      }
;;;329      printf(":  %d", Tmp_MM); 
00012c  4621              MOV      r1,r4
00012e  a0cd              ADR      r0,|L1.1124|
000130  f7fffffe          BL       __2printf
;;;330      printf("\r\n  Please Set Seconds");
000134  a0d3              ADR      r0,|L1.1156|
000136  f7fffffe          BL       __2printf
;;;331      while(Tmp_SS == 0xFF)
00013a  e003              B        |L1.324|
                  |L1.316|
;;;332      {
;;;333        Tmp_SS = USART_Scanf(59);
00013c  203b              MOVS     r0,#0x3b
00013e  f7fffffe          BL       USART_Scanf
000142  4605              MOV      r5,r0
                  |L1.324|
000144  2dff              CMP      r5,#0xff              ;331
000146  d0f9              BEQ      |L1.316|
;;;334      }
;;;335      printf(":  %d", Tmp_SS); 
000148  4629              MOV      r1,r5
00014a  a0c6              ADR      r0,|L1.1124|
00014c  f7fffffe          BL       __2printf
;;;336    
;;;337      /* Return the value to store in RTC counter register */
;;;338      return((Tmp_HH*3600 + Tmp_MM*60 + Tmp_SS));
000150  f44f6061          MOV      r0,#0xe10
000154  4370              MULS     r0,r6,r0
000156  ebc41104          RSB      r1,r4,r4,LSL #4
00015a  eb000081          ADD      r0,r0,r1,LSL #2
00015e  4428              ADD      r0,r0,r5
;;;339    }
000160  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

                  Time_Adjust PROC
;;;347    *******************************************************************************/
;;;348    void Time_Adjust(void)
000162  b510              PUSH     {r4,lr}
;;;349    {
;;;350      /* Wait until last write operation on RTC registers has finished */
;;;351      RTC_WaitForLastTask(); 
000164  f7fffffe          BL       RTC_WaitForLastTask
;;;352      /* Change the current time */
;;;353      RTC_SetCounter(Time_Regulate());
000168  f7fffffe          BL       Time_Regulate
00016c  4604              MOV      r4,r0
00016e  f7fffffe          BL       RTC_SetCounter
;;;354      /* Wait until last write operation on RTC registers has finished */
;;;355      RTC_WaitForLastTask();   
000172  f7fffffe          BL       RTC_WaitForLastTask
;;;356    }
000176  bd10              POP      {r4,pc}
;;;357    
                          ENDP

                  RTC_Configuration PROC
;;;234    *******************************************************************************/
;;;235    void RTC_Configuration(void)
000178  b510              PUSH     {r4,lr}
;;;236    {
;;;237      /* Enable PWR and BKP clocks */
;;;238      RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
00017a  2101              MOVS     r1,#1
00017c  f04f50c0          MOV      r0,#0x18000000
000180  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;239      
;;;240      /* Allow access to BKP Domain */
;;;241      PWR_BackupAccessCmd(ENABLE);
000184  2001              MOVS     r0,#1
000186  f7fffffe          BL       PWR_BackupAccessCmd
;;;242    
;;;243      /* Reset Backup Domain */
;;;244      BKP_DeInit();
00018a  f7fffffe          BL       BKP_DeInit
;;;245    
;;;246    #ifdef RTCClockSource_LSI
;;;247      /* Enable LSI */ 
;;;248      RCC_LSICmd(ENABLE);
;;;249      /* Wait till LSI is ready */
;;;250      while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;251      {
;;;252      }
;;;253    
;;;254      /* Select LSI as RTC Clock Source */
;;;255      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);  
;;;256    #elif defined	RTCClockSource_LSE  
;;;257      /* Enable LSE */
;;;258      RCC_LSEConfig(RCC_LSE_ON);
00018e  2001              MOVS     r0,#1
000190  f7fffffe          BL       RCC_LSEConfig
;;;259      /* Wait till LSE is ready */
;;;260      while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
000194  bf00              NOP      
                  |L1.406|
000196  2041              MOVS     r0,#0x41
000198  f7fffffe          BL       RCC_GetFlagStatus
00019c  2800              CMP      r0,#0
00019e  d0fa              BEQ      |L1.406|
;;;261      {
;;;262      }
;;;263    
;;;264      /* Select LSE as RTC Clock Source */
;;;265      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);  
0001a0  f44f7080          MOV      r0,#0x100
0001a4  f7fffffe          BL       RCC_RTCCLKConfig
;;;266    #endif
;;;267    
;;;268    
;;;269      /* Enable RTC Clock */
;;;270      RCC_RTCCLKCmd(ENABLE);
0001a8  2001              MOVS     r0,#1
0001aa  f7fffffe          BL       RCC_RTCCLKCmd
;;;271    
;;;272    
;;;273    #ifdef RTCClockOutput_Enable  
;;;274      /* Disable the Tamper Pin */
;;;275      BKP_TamperPinCmd(DISABLE); /* To output RTCCLK/64 on Tamper pin, the tamper
;;;276                                   functionality must be disabled */
;;;277                                   
;;;278      /* Enable RTC Clock Output on Tamper Pin */
;;;279      BKP_RTCCalibrationClockOutputCmd(ENABLE);
;;;280    #endif 
;;;281    
;;;282      /* Wait for RTC registers synchronization */
;;;283      RTC_WaitForSynchro();
0001ae  f7fffffe          BL       RTC_WaitForSynchro
;;;284    
;;;285      /* Wait until last write operation on RTC registers has finished */
;;;286      RTC_WaitForLastTask();
0001b2  f7fffffe          BL       RTC_WaitForLastTask
;;;287      
;;;288      /* Enable the RTC Second */  
;;;289      RTC_ITConfig(RTC_IT_SEC, ENABLE);
0001b6  2101              MOVS     r1,#1
0001b8  4608              MOV      r0,r1
0001ba  f7fffffe          BL       RTC_ITConfig
;;;290    
;;;291      /* Wait until last write operation on RTC registers has finished */
;;;292      RTC_WaitForLastTask();
0001be  f7fffffe          BL       RTC_WaitForLastTask
;;;293      
;;;294      /* Set RTC prescaler: set RTC period to 1sec */
;;;295    #ifdef RTCClockSource_LSI
;;;296      RTC_SetPrescaler(31999); /* RTC period = RTCCLK/RTC_PR = (32.000 KHz)/(31999+1) */
;;;297    #elif defined	RTCClockSource_LSE
;;;298      RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
0001c2  f64770ff          MOV      r0,#0x7fff
0001c6  f7fffffe          BL       RTC_SetPrescaler
;;;299    #endif
;;;300      
;;;301      /* Wait until last write operation on RTC registers has finished */
;;;302      RTC_WaitForLastTask();
0001ca  f7fffffe          BL       RTC_WaitForLastTask
;;;303    }
0001ce  bd10              POP      {r4,pc}
;;;304    
                          ENDP

                  USART_Configuration PROC
;;;409    *******************************************************************************/
;;;410    void USART_Configuration(void)
0001d0  b500              PUSH     {lr}
;;;411    {
0001d2  b087              SUB      sp,sp,#0x1c
;;;412      USART_InitTypeDef USART_InitStructure;
;;;413      USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;414    /* USART1 configuration -----------------------------------------------
;;;415    
;;;416    -------*/
;;;417      /* USART1 configured as follow:
;;;418            - BaudRate = 115200 baud  
;;;419            - Word Length = 8 Bits
;;;420            - One Stop Bit
;;;421            - No parity
;;;422            - Hardware flow control disabled (RTS and CTS signals)
;;;423            - Receive and transmit enabled
;;;424            - USART Clock disabled
;;;425            - USART CPOL: Clock is active low
;;;426            - USART CPHA: Data is captured on the middle 
;;;427            - USART LastBit: The clock pulse of the last data bit is not 
;;;428    
;;;429    output to 
;;;430                             the SCLK pin
;;;431      */
;;;432    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
0001d4  f04f0000          MOV      r0,#0
0001d8  f8ad0004          STRH     r0,[sp,#4]
;;;433    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
0001dc  f8ad0006          STRH     r0,[sp,#6]
;;;434    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
0001e0  f44f7000          MOV      r0,#0x200
0001e4  f8ad0008          STRH     r0,[sp,#8]
;;;435    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
0001e8  f04f0000          MOV      r0,#0
0001ec  f8ad000a          STRH     r0,[sp,#0xa]
;;;436    /* Configure the USART1 synchronous paramters */
;;;437    USART_ClockInit(USART1, &USART_ClockInitStructure);
0001f0  a901              ADD      r1,sp,#4
0001f2  487d              LDR      r0,|L1.1000|
0001f4  f7fffffe          BL       USART_ClockInit
;;;438    
;;;439    USART_InitStructure.USART_BaudRate = 19200;
0001f8  f44f4096          MOV      r0,#0x4b00
0001fc  9003              STR      r0,[sp,#0xc]
;;;440    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001fe  f04f0000          MOV      r0,#0
000202  f8ad0010          STRH     r0,[sp,#0x10]
;;;441    USART_InitStructure.USART_StopBits = USART_StopBits_1;
000206  f8ad0012          STRH     r0,[sp,#0x12]
;;;442    USART_InitStructure.USART_Parity = USART_Parity_No ;
00020a  f8ad0014          STRH     r0,[sp,#0x14]
;;;443    USART_InitStructure.USART_HardwareFlowControl = 
00020e  f8ad0018          STRH     r0,[sp,#0x18]
;;;444    
;;;445    USART_HardwareFlowControl_None;
;;;446    
;;;447    
;;;448    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000212  f04f000c          MOV      r0,#0xc
000216  f8ad0016          STRH     r0,[sp,#0x16]
;;;449    /* Configure USART1 basic and asynchronous paramters */
;;;450    USART_Init(USART1, &USART_InitStructure);
00021a  a903              ADD      r1,sp,#0xc
00021c  4872              LDR      r0,|L1.1000|
00021e  f7fffffe          BL       USART_Init
;;;451        
;;;452      /* Enable USART1 */
;;;453      USART_Cmd(USART1, ENABLE);
000222  2101              MOVS     r1,#1
000224  4870              LDR      r0,|L1.1000|
000226  f7fffffe          BL       USART_Cmd
;;;454    }
00022a  b007              ADD      sp,sp,#0x1c
00022c  bd00              POP      {pc}
;;;455    
                          ENDP

                  GPIO_Configuration PROC
;;;206    *******************************************************************************/
;;;207    void GPIO_Configuration(void)
00022e  b508              PUSH     {r3,lr}
;;;208    {
;;;209      GPIO_InitTypeDef GPIO_InitStructure;
;;;210        
;;;211      /* Configure PD.10 as output push-pull */
;;;212      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000230  f44f6080          MOV      r0,#0x400
000234  f8ad0000          STRH     r0,[sp,#0]
;;;213      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000238  f04f0003          MOV      r0,#3
00023c  f88d0002          STRB     r0,[sp,#2]
;;;214      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000240  f04f0010          MOV      r0,#0x10
000244  f88d0003          STRB     r0,[sp,#3]
;;;215      GPIO_Init(GPIOD, &GPIO_InitStructure);
000248  4669              MOV      r1,sp
00024a  4894              LDR      r0,|L1.1180|
00024c  f7fffffe          BL       GPIO_Init
;;;216    
;;;217      /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;218      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000250  f44f7000          MOV      r0,#0x200
000254  f8ad0000          STRH     r0,[sp,#0]
;;;219      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000258  f04f0018          MOV      r0,#0x18
00025c  f88d0003          STRB     r0,[sp,#3]
;;;220      GPIO_Init(GPIOA, &GPIO_InitStructure);
000260  4669              MOV      r1,sp
000262  488f              LDR      r0,|L1.1184|
000264  f7fffffe          BL       GPIO_Init
;;;221        
;;;222      /* Configure USART1 Rx (PA.10) as input floating */
;;;223      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000268  f44f6080          MOV      r0,#0x400
00026c  f8ad0000          STRH     r0,[sp,#0]
;;;224      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000270  f04f0004          MOV      r0,#4
000274  f88d0003          STRB     r0,[sp,#3]
;;;225      GPIO_Init(GPIOA, &GPIO_InitStructure);
000278  4669              MOV      r1,sp
00027a  4889              LDR      r0,|L1.1184|
00027c  f7fffffe          BL       GPIO_Init
;;;226    }
000280  bd08              POP      {r3,pc}
;;;227    
                          ENDP

                  NVIC_Configuration PROC
;;;184    *******************************************************************************/
;;;185    void NVIC_Configuration(void)
000282  b508              PUSH     {r3,lr}
;;;186    {
;;;187      NVIC_InitTypeDef NVIC_InitStructure;
;;;188      
;;;189      /* Configure one bit for preemption priority */
;;;190      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000284  f44f60c0          MOV      r0,#0x600
000288  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;191      
;;;192      /* Enable the RTC Interrupt */
;;;193      NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQChannel;
00028c  f04f0003          MOV      r0,#3
000290  f88d0000          STRB     r0,[sp,#0]
;;;194      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000294  f04f0001          MOV      r0,#1
000298  f88d0001          STRB     r0,[sp,#1]
;;;195      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00029c  f04f0000          MOV      r0,#0
0002a0  f88d0002          STRB     r0,[sp,#2]
;;;196      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0002a4  f04f0001          MOV      r0,#1
0002a8  f88d0003          STRB     r0,[sp,#3]
;;;197      NVIC_Init(&NVIC_InitStructure);
0002ac  4668              MOV      r0,sp
0002ae  f7fffffe          BL       NVIC_Init
;;;198    }
0002b2  bd08              POP      {r3,pc}
;;;199    
                          ENDP

                  RCC_Configuration PROC
;;;125    *******************************************************************************/
;;;126    void RCC_Configuration(void)
0002b4  b510              PUSH     {r4,lr}
;;;127    {
;;;128      /* RCC system reset(for debug purpose) */
;;;129      RCC_DeInit();
0002b6  f7fffffe          BL       RCC_DeInit
;;;130    
;;;131      /* Enable HSE */
;;;132      RCC_HSEConfig(RCC_HSE_ON);
0002ba  f44f3080          MOV      r0,#0x10000
0002be  f7fffffe          BL       RCC_HSEConfig
;;;133    
;;;134      /* Wait till HSE is ready */
;;;135      HSEStartUpStatus = RCC_WaitForHSEStartUp();
0002c2  f7fffffe          BL       RCC_WaitForHSEStartUp
0002c6  4977              LDR      r1,|L1.1188|
0002c8  7008              STRB     r0,[r1,#0]
;;;136    
;;;137      if(HSEStartUpStatus == SUCCESS)
0002ca  4608              MOV      r0,r1
0002cc  7800              LDRB     r0,[r0,#0]  ; HSEStartUpStatus
0002ce  2801              CMP      r0,#1
0002d0  d126              BNE      |L1.800|
;;;138      {
;;;139        /* HCLK = SYSCLK */
;;;140        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
0002d2  2000              MOVS     r0,#0
0002d4  f7fffffe          BL       RCC_HCLKConfig
;;;141      
;;;142        /* PCLK2 = HCLK */
;;;143        RCC_PCLK2Config(RCC_HCLK_Div1); 
0002d8  2000              MOVS     r0,#0
0002da  f7fffffe          BL       RCC_PCLK2Config
;;;144    
;;;145        /* PCLK1 = HCLK/2 */
;;;146        RCC_PCLK1Config(RCC_HCLK_Div2);
0002de  f44f6080          MOV      r0,#0x400
0002e2  f7fffffe          BL       RCC_PCLK1Config
;;;147    
;;;148        /* Flash 2 wait state */
;;;149        FLASH_SetLatency(FLASH_Latency_2);
0002e6  2002              MOVS     r0,#2
0002e8  f7fffffe          BL       FLASH_SetLatency
;;;150        /* Enable Prefetch Buffer */
;;;151        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
0002ec  2010              MOVS     r0,#0x10
0002ee  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;152    
;;;153        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;154        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
0002f2  f44f11e0          MOV      r1,#0x1c0000
0002f6  f44f3080          MOV      r0,#0x10000
0002fa  f7fffffe          BL       RCC_PLLConfig
;;;155    
;;;156        /* Enable PLL */ 
;;;157        RCC_PLLCmd(ENABLE);
0002fe  2001              MOVS     r0,#1
000300  f7fffffe          BL       RCC_PLLCmd
;;;158    
;;;159        /* Wait till PLL is ready */
;;;160        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000304  bf00              NOP      
                  |L1.774|
000306  2039              MOVS     r0,#0x39
000308  f7fffffe          BL       RCC_GetFlagStatus
00030c  2800              CMP      r0,#0
00030e  d0fa              BEQ      |L1.774|
;;;161        {
;;;162        }
;;;163    
;;;164        /* Select PLL as system clock source */
;;;165        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000310  2002              MOVS     r0,#2
000312  f7fffffe          BL       RCC_SYSCLKConfig
;;;166    
;;;167        /* Wait till PLL is used as system clock source */
;;;168        while(RCC_GetSYSCLKSource() != 0x08)
000316  bf00              NOP      
                  |L1.792|
000318  f7fffffe          BL       RCC_GetSYSCLKSource
00031c  2808              CMP      r0,#8
00031e  d1fb              BNE      |L1.792|
                  |L1.800|
;;;169        {
;;;170        }
;;;171      }
;;;172    
;;;173      /* Enable USART1, GPIOA and GPIOC clocks */
;;;174      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOD |
000320  2101              MOVS     r1,#1
000322  f2440034          MOV      r0,#0x4034
000326  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;175                             RCC_APB2Periph_GPIOC , ENABLE);
;;;176    }
00032a  bd10              POP      {r4,pc}
;;;177    
                          ENDP

                  main PROC
;;;53     *******************************************************************************/
;;;54     int main(void)
00032c  f7fffffe          BL       RCC_Configuration
;;;55     {
;;;56     #ifdef DEBUG
;;;57       debug();
;;;58     #endif
;;;59     
;;;60       /* System Clocks Configuration */
;;;61       RCC_Configuration();
;;;62      
;;;63       /* NVIC configuration */
;;;64       NVIC_Configuration();
000330  f7fffffe          BL       NVIC_Configuration
;;;65     
;;;66       /* Configure the GPIOs */
;;;67       GPIO_Configuration();
000334  f7fffffe          BL       GPIO_Configuration
;;;68       
;;;69       /* Configure the USART1 */
;;;70       USART_Configuration();
000338  f7fffffe          BL       USART_Configuration
;;;71          
;;;72       if(BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)
00033c  2004              MOVS     r0,#4
00033e  f7fffffe          BL       BKP_ReadBackupRegister
000342  f5a04125          SUB      r1,r0,#0xa500
000346  39a5              SUBS     r1,r1,#0xa5
000348  d00f              BEQ      |L1.874|
;;;73       {
;;;74         /* Backup data register value is not correct or not yet programmed (when
;;;75            the first time the program is executed) */
;;;76     
;;;77         printf("\r\n\n RTC not yet configured....");
00034a  a057              ADR      r0,|L1.1192|
00034c  f7fffffe          BL       __2printf
;;;78        
;;;79         /* RTC Configuration */
;;;80         RTC_Configuration();
000350  f7fffffe          BL       RTC_Configuration
;;;81     
;;;82          printf("\r\n RTC configured....");
000354  a05c              ADR      r0,|L1.1224|
000356  f7fffffe          BL       __2printf
;;;83      
;;;84         /* Adjust time by values entred by the user on the hyperterminal */
;;;85         Time_Adjust();
00035a  f7fffffe          BL       Time_Adjust
;;;86     
;;;87         BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);    
00035e  f24a51a5          MOV      r1,#0xa5a5
000362  2004              MOVS     r0,#4
000364  f7fffffe          BL       BKP_WriteBackupRegister
000368  e019              B        |L1.926|
                  |L1.874|
;;;88       }
;;;89       else
;;;90       {
;;;91         /* Check if the Power On Reset flag is set */
;;;92         if(RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
00036a  207b              MOVS     r0,#0x7b
00036c  f7fffffe          BL       RCC_GetFlagStatus
000370  b118              CBZ      r0,|L1.890|
;;;93         {
;;;94           printf("\r\n\n Power On Reset occurred....");
000372  a05b              ADR      r0,|L1.1248|
000374  f7fffffe          BL       __2printf
000378  e006              B        |L1.904|
                  |L1.890|
;;;95         }
;;;96         /* Check if the Pin Reset flag is set */
;;;97         else if(RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
00037a  207a              MOVS     r0,#0x7a
00037c  f7fffffe          BL       RCC_GetFlagStatus
000380  b110              CBZ      r0,|L1.904|
;;;98         {
;;;99           printf("\r\n\n External Reset occurred....");
000382  a05f              ADR      r0,|L1.1280|
000384  f7fffffe          BL       __2printf
                  |L1.904|
;;;100        }
;;;101    
;;;102        printf("\r\n No need to configure RTC....");    
000388  a065              ADR      r0,|L1.1312|
00038a  f7fffffe          BL       __2printf
;;;103        /* Wait for RTC registers synchronization */
;;;104        RTC_WaitForSynchro();
00038e  f7fffffe          BL       RTC_WaitForSynchro
;;;105    
;;;106        /* Enable the RTC Second */  
;;;107        RTC_ITConfig(RTC_IT_SEC, ENABLE);
000392  2101              MOVS     r1,#1
000394  4608              MOV      r0,r1
000396  f7fffffe          BL       RTC_ITConfig
;;;108        /* Wait until last write operation on RTC registers has finished */
;;;109        RTC_WaitForLastTask();
00039a  f7fffffe          BL       RTC_WaitForLastTask
                  |L1.926|
;;;110      }
;;;111    
;;;112      /* Clear reset flags */
;;;113      RCC_ClearFlag();
00039e  f7fffffe          BL       RCC_ClearFlag
;;;114      
;;;115      /* Display time in infinte loop */
;;;116      Time_Show();
0003a2  f7fffffe          BL       Time_Show
;;;117    }
;;;118    
                          ENDP

                  fputc PROC
;;;463    
;;;464    int fputc(int ch, FILE *f)
0003a6  b570              PUSH     {r4-r6,lr}
;;;465    {
0003a8  4604              MOV      r4,r0
0003aa  460d              MOV      r5,r1
;;;466    #ifdef DBG_ITM
;;;467    /* 将Printf内容发往ITM激励寄存器端口  */
;;;468      if (DEMCR & TRCENA) {
;;;469        while (ITM_Port32(0) == 0);
;;;470        ITM_Port8(0) = ch;
;;;471      }
;;;472    #else  
;;;473    /* 将Printf内容发往串口 */
;;;474      USART_SendData(USART1, (unsigned char) ch);
0003ac  b2e1              UXTB     r1,r4
0003ae  480e              LDR      r0,|L1.1000|
0003b0  f7fffffe          BL       USART_SendData
;;;475      while (!(USART1->SR & USART_FLAG_TXE));
0003b4  bf00              NOP      
                  |L1.950|
0003b6  480c              LDR      r0,|L1.1000|
0003b8  8800              LDRH     r0,[r0,#0]
0003ba  f0100f80          TST      r0,#0x80
0003be  d0fa              BEQ      |L1.950|
;;;476    #endif  
;;;477      return (ch);
0003c0  4620              MOV      r0,r4
;;;478    }
0003c2  bd70              POP      {r4-r6,pc}
;;;479    
                          ENDP

                  |L1.964|
0003c4  54696d65          DCB      "Time: %0.2d:%0.2d:%0.2d\r",0
0003c8  3a202530
0003cc  2e32643a
0003d0  25302e32
0003d4  643a2530
0003d8  2e32640d
0003dc  00      
0003dd  00                DCB      0
0003de  00                DCB      0
0003df  00                DCB      0
                  |L1.992|
0003e0  0a0d00            DCB      "\n\r",0
0003e3  00                DCB      0
                  |L1.996|
                          DCD      TimeDisplay
                  |L1.1000|
                          DCD      0x40013800
                  |L1.1004|
0003ec  0a0d506c          DCB      "\n\rPlease enter valid number between 0 and 9",0
0003f0  65617365
0003f4  20656e74
0003f8  65722076
0003fc  616c6964
000400  206e756d
000404  62657220
000408  62657477
00040c  65656e20
000410  3020616e
000414  64203900
                  |L1.1048|
000418  0a0d506c          DCB      "\n\rPlease enter valid number between 0 and %d",0
00041c  65617365
000420  20656e74
000424  65722076
000428  616c6964
00042c  206e756d
000430  62657220
000434  62657477
000438  65656e20
00043c  3020616e
000440  64202564
000444  00      
000445  00                DCB      0
000446  00                DCB      0
000447  00                DCB      0
                  |L1.1096|
                          DCD      ||.constdata||
                  |L1.1100|
00044c  0d0a2020          DCB      "\r\n  Please Set Hours",0
000450  506c6561
000454  73652053
000458  65742048
00045c  6f757273
000460  00      
000461  00                DCB      0
000462  00                DCB      0
000463  00                DCB      0
                  |L1.1124|
000464  3a202025          DCB      ":  %d",0
000468  6400    
00046a  00                DCB      0
00046b  00                DCB      0
                  |L1.1132|
00046c  0d0a2020          DCB      "\r\n  Please Set Minutes",0
000470  506c6561
000474  73652053
000478  6574204d
00047c  696e7574
000480  657300  
000483  00                DCB      0
                  |L1.1156|
000484  0d0a2020          DCB      "\r\n  Please Set Seconds",0
000488  506c6561
00048c  73652053
000490  65742053
000494  65636f6e
000498  647300  
00049b  00                DCB      0
                  |L1.1180|
                          DCD      0x40011400
                  |L1.1184|
                          DCD      0x40010800
                  |L1.1188|
                          DCD      HSEStartUpStatus
                  |L1.1192|
0004a8  0d0a0a20          DCB      "\r\n\n RTC not yet configured....",0
0004ac  52544320
0004b0  6e6f7420
0004b4  79657420
0004b8  636f6e66
0004bc  69677572
0004c0  65642e2e
0004c4  2e2e00  
0004c7  00                DCB      0
                  |L1.1224|
0004c8  0d0a2052          DCB      "\r\n RTC configured....",0
0004cc  54432063
0004d0  6f6e6669
0004d4  67757265
0004d8  642e2e2e
0004dc  2e00    
0004de  00                DCB      0
0004df  00                DCB      0
                  |L1.1248|
0004e0  0d0a0a20          DCB      "\r\n\n Power On Reset occurred....",0
0004e4  506f7765
0004e8  72204f6e
0004ec  20526573
0004f0  6574206f
0004f4  63637572
0004f8  7265642e
0004fc  2e2e2e00
                  |L1.1280|
000500  0d0a0a20          DCB      "\r\n\n External Reset occurred....",0
000504  45787465
000508  726e616c
00050c  20526573
000510  6574206f
000514  63637572
000518  7265642e
00051c  2e2e2e00
                  |L1.1312|
000520  0d0a204e          DCB      "\r\n No need to configure RTC....",0
000524  6f206e65
000528  65642074
00052c  6f20636f
000530  6e666967
000534  75726520
000538  5254432e
00053c  2e2e2e00

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  0d0a3d3d          DCB      0x0d,0x0a,0x3d,0x3d
000004  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000008  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00000c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000010  54696d65          DCB      0x54,0x69,0x6d,0x65
000014  20536574          DCB      0x20,0x53,0x65,0x74
000018  74696e67          DCB      0x74,0x69,0x6e,0x67
00001c  733d3d3d          DCB      0x73,0x3d,0x3d,0x3d
000020  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000024  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000028  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00002c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000030  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000034  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000038  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00003c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000040  3d3d00            DCB      0x3d,0x3d,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  TimeDisplay
                          DCD      0x00000000
                  HSEStartUpStatus
000004  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
