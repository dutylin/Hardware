; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\main.o --depend=.\output\main.d --device=DARMSTM --apcs=interwork -O0 -I.\ -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\output\main.crf main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Time_Display PROC
;;;364    *******************************************************************************/
;;;365    void Time_Display(u32 TimeVar)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;366    { 
000004  4604              MOV      r4,r0
;;;367      u32 THH = 0, TMM = 0, TSS = 0;
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;368    
;;;369      /* Compute  hours */
;;;370      THH = TimeVar/3600;
00000c  f44f6061          MOV      r0,#0xe10
000010  fbb4f5f0          UDIV     r5,r4,r0
;;;371      /* Compute minutes */
;;;372      TMM = (TimeVar % 3600)/60;
000014  fbb4f1f0          UDIV     r1,r4,r0
000018  fb004011          MLS      r0,r0,r1,r4
00001c  213c              MOVS     r1,#0x3c
00001e  fbb0f6f1          UDIV     r6,r0,r1
;;;373      /* Compute seconds */
;;;374      TSS = (TimeVar % 3600)% 60;
000022  f44f6061          MOV      r0,#0xe10
000026  fbb4f1f0          UDIV     r1,r4,r0
00002a  fb004011          MLS      r0,r0,r1,r4
00002e  213c              MOVS     r1,#0x3c
000030  fbb0f2f1          UDIV     r2,r0,r1
000034  fb010712          MLS      r7,r1,r2,r0
;;;375    
;;;376      printf("Time: %0.2d:%0.2d:%0.2d\r",THH, TMM, TSS);
000038  463b              MOV      r3,r7
00003a  4632              MOV      r2,r6
00003c  4629              MOV      r1,r5
00003e  a0d8              ADR      r0,|L1.928|
000040  f7fffffe          BL       __2printf
;;;377    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;378    
                          ENDP

                  Time_Show PROC
;;;385    ******************************************************************************/
;;;386    void Time_Show(void)
000048  b510              PUSH     {r4,lr}
;;;387    {
;;;388      printf("\n\r");
00004a  a0dc              ADR      r0,|L1.956|
00004c  f7fffffe          BL       __2printf
;;;389      
;;;390      /* Infinite loop */ 
;;;391      while(1)
000050  e00b              B        |L1.106|
                  |L1.82|
;;;392      {
;;;393        /* If 1s has paased */
;;;394        if(TimeDisplay == 1)
000052  48db              LDR      r0,|L1.960|
000054  6800              LDR      r0,[r0,#0]  ; TimeDisplay
000056  2801              CMP      r0,#1
000058  d107              BNE      |L1.106|
;;;395        {    
;;;396          /* Display current time */
;;;397          Time_Display(RTC_GetCounter());
00005a  f7fffffe          BL       RTC_GetCounter
00005e  4604              MOV      r4,r0
000060  f7fffffe          BL       Time_Display
;;;398          TimeDisplay = 0;
000064  2000              MOVS     r0,#0
000066  49d6              LDR      r1,|L1.960|
000068  6008              STR      r0,[r1,#0]  ; TimeDisplay
                  |L1.106|
00006a  e7f2              B        |L1.82|
;;;399        }
;;;400      }
;;;401    }
;;;402    
                          ENDP

                  USART_Scanf PROC
;;;487    *******************************************************************************/
;;;488    u8 USART_Scanf(u32 value)
00006c  b57c              PUSH     {r2-r6,lr}
;;;489    {
00006e  4605              MOV      r5,r0
;;;490      u32 index = 0;
000070  2400              MOVS     r4,#0
;;;491      u32 tmp[2] = {0, 0};     
000072  4668              MOV      r0,sp
000074  2100              MOVS     r1,#0
000076  460a              MOV      r2,r1
000078  c006              STM      r0!,{r1,r2}
;;;492      
;;;493      while(index < 2)
00007a  e01b              B        |L1.180|
                  |L1.124|
;;;494      {
;;;495        /* Loop until RXNE = 1 */
;;;496        while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
00007c  bf00              NOP      
                  |L1.126|
00007e  2120              MOVS     r1,#0x20
000080  48d0              LDR      r0,|L1.964|
000082  f7fffffe          BL       USART_GetFlagStatus
000086  2800              CMP      r0,#0
000088  d0f9              BEQ      |L1.126|
;;;497        {
;;;498        }
;;;499        tmp[index++] = (USART_ReceiveData(USART1));
00008a  48ce              LDR      r0,|L1.964|
00008c  f7fffffe          BL       USART_ReceiveData
000090  4621              MOV      r1,r4
000092  1c64              ADDS     r4,r4,#1
000094  f84d0021          STR      r0,[sp,r1,LSL #2]
;;;500        if((tmp[index - 1] < 0x30) || (tmp[index - 1] > 0x39))
000098  1e60              SUBS     r0,r4,#1
00009a  f85d0020          LDR      r0,[sp,r0,LSL #2]
00009e  2830              CMP      r0,#0x30
0000a0  d304              BCC      |L1.172|
0000a2  1e60              SUBS     r0,r4,#1
0000a4  f85d0020          LDR      r0,[sp,r0,LSL #2]
0000a8  2839              CMP      r0,#0x39
0000aa  d903              BLS      |L1.180|
                  |L1.172|
;;;501        {
;;;502          printf("\n\rPlease enter valid number between 0 and 9");
0000ac  a0c6              ADR      r0,|L1.968|
0000ae  f7fffffe          BL       __2printf
;;;503          index--;
0000b2  1e64              SUBS     r4,r4,#1
                  |L1.180|
0000b4  2c02              CMP      r4,#2                 ;493
0000b6  d3e1              BCC      |L1.124|
;;;504        }
;;;505      }
;;;506      /* Calculate the Corresponding value */
;;;507      index = (tmp[1] - 0x30) + ((tmp[0] - 0x30) * 10); 
0000b8  9801              LDR      r0,[sp,#4]
0000ba  3830              SUBS     r0,r0,#0x30
0000bc  9900              LDR      r1,[sp,#0]
0000be  3930              SUBS     r1,r1,#0x30
0000c0  eb010181          ADD      r1,r1,r1,LSL #2
0000c4  eb000441          ADD      r4,r0,r1,LSL #1
;;;508      /* Checks */
;;;509      if(index > value)
0000c8  42ac              CMP      r4,r5
0000ca  d905              BLS      |L1.216|
;;;510      {
;;;511        printf("\n\rPlease enter valid number between 0 and %d", value);
0000cc  4629              MOV      r1,r5
0000ce  a0c9              ADR      r0,|L1.1012|
0000d0  f7fffffe          BL       __2printf
;;;512        return 0xFF;
0000d4  20ff              MOVS     r0,#0xff
                  |L1.214|
;;;513      }
;;;514      return index;
;;;515    }
0000d6  bd7c              POP      {r2-r6,pc}
                  |L1.216|
0000d8  b2e0              UXTB     r0,r4                 ;514
0000da  e7fc              B        |L1.214|
;;;516    
                          ENDP

                  Time_Regulate PROC
;;;311    *******************************************************************************/
;;;312    u32 Time_Regulate(void)
0000dc  b570              PUSH     {r4-r6,lr}
;;;313    {
;;;314      u32 Tmp_HH = 0xFF, Tmp_MM = 0xFF, Tmp_SS = 0xFF;
0000de  24ff              MOVS     r4,#0xff
0000e0  25ff              MOVS     r5,#0xff
0000e2  26ff              MOVS     r6,#0xff
;;;315    
;;;316      printf("\r\n==============Time Settings=====================================");
0000e4  48cf              LDR      r0,|L1.1060|
0000e6  f7fffffe          BL       __2printf
;;;317      printf("\r\n  Please Set Hours");
0000ea  a0cf              ADR      r0,|L1.1064|
0000ec  f7fffffe          BL       __2printf
;;;318      
;;;319      while(Tmp_HH == 0xFF)
0000f0  e003              B        |L1.250|
                  |L1.242|
;;;320      {
;;;321        Tmp_HH = USART_Scanf(23);
0000f2  2017              MOVS     r0,#0x17
0000f4  f7fffffe          BL       USART_Scanf
0000f8  4604              MOV      r4,r0
                  |L1.250|
0000fa  2cff              CMP      r4,#0xff              ;319
0000fc  d0f9              BEQ      |L1.242|
;;;322      }
;;;323      printf(":  %d", Tmp_HH); 
0000fe  4621              MOV      r1,r4
000100  a0cf              ADR      r0,|L1.1088|
000102  f7fffffe          BL       __2printf
;;;324      printf("\r\n  Please Set Minutes");
000106  a0d0              ADR      r0,|L1.1096|
000108  f7fffffe          BL       __2printf
;;;325      while(Tmp_MM == 0xFF)
00010c  e003              B        |L1.278|
                  |L1.270|
;;;326      {
;;;327        Tmp_MM = USART_Scanf(59);
00010e  203b              MOVS     r0,#0x3b
000110  f7fffffe          BL       USART_Scanf
000114  4605              MOV      r5,r0
                  |L1.278|
000116  2dff              CMP      r5,#0xff              ;325
000118  d0f9              BEQ      |L1.270|
;;;328      }
;;;329      printf(":  %d", Tmp_MM); 
00011a  4629              MOV      r1,r5
00011c  a0c8              ADR      r0,|L1.1088|
00011e  f7fffffe          BL       __2printf
;;;330      printf("\r\n  Please Set Seconds");
000122  a0cf              ADR      r0,|L1.1120|
000124  f7fffffe          BL       __2printf
;;;331      while(Tmp_SS == 0xFF)
000128  e003              B        |L1.306|
                  |L1.298|
;;;332      {
;;;333        Tmp_SS = USART_Scanf(59);
00012a  203b              MOVS     r0,#0x3b
00012c  f7fffffe          BL       USART_Scanf
000130  4606              MOV      r6,r0
                  |L1.306|
000132  2eff              CMP      r6,#0xff              ;331
000134  d0f9              BEQ      |L1.298|
;;;334      }
;;;335      printf(":  %d", Tmp_SS); 
000136  4631              MOV      r1,r6
000138  a0c1              ADR      r0,|L1.1088|
00013a  f7fffffe          BL       __2printf
;;;336    
;;;337      /* Return the value to store in RTC counter register */
;;;338      return((Tmp_HH*3600 + Tmp_MM*60 + Tmp_SS));
00013e  f44f6061          MOV      r0,#0xe10
000142  4360              MULS     r0,r4,r0
000144  ebc51105          RSB      r1,r5,r5,LSL #4
000148  eb000081          ADD      r0,r0,r1,LSL #2
00014c  4430              ADD      r0,r0,r6
;;;339    }
00014e  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

                  Time_Adjust PROC
;;;347    *******************************************************************************/
;;;348    void Time_Adjust(void)
000150  b510              PUSH     {r4,lr}
;;;349    {
;;;350      /* Wait until last write operation on RTC registers has finished */
;;;351      RTC_WaitForLastTask(); 
000152  f7fffffe          BL       RTC_WaitForLastTask
;;;352      /* Change the current time */
;;;353      RTC_SetCounter(Time_Regulate());
000156  f7fffffe          BL       Time_Regulate
00015a  4604              MOV      r4,r0
00015c  f7fffffe          BL       RTC_SetCounter
;;;354      /* Wait until last write operation on RTC registers has finished */
;;;355      RTC_WaitForLastTask();   
000160  f7fffffe          BL       RTC_WaitForLastTask
;;;356    }
000164  bd10              POP      {r4,pc}
;;;357    
                          ENDP

                  RTC_Configuration PROC
;;;234    *******************************************************************************/
;;;235    void RTC_Configuration(void)
000166  b510              PUSH     {r4,lr}
;;;236    {
;;;237      /* Enable PWR and BKP clocks */
;;;238      RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
000168  2101              MOVS     r1,#1
00016a  f04f50c0          MOV      r0,#0x18000000
00016e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;239      
;;;240      /* Allow access to BKP Domain */
;;;241      PWR_BackupAccessCmd(ENABLE);
000172  2001              MOVS     r0,#1
000174  f7fffffe          BL       PWR_BackupAccessCmd
;;;242    
;;;243      /* Reset Backup Domain */
;;;244      BKP_DeInit();
000178  f7fffffe          BL       BKP_DeInit
;;;245    
;;;246    #ifdef RTCClockSource_LSI
;;;247      /* Enable LSI */ 
;;;248      RCC_LSICmd(ENABLE);
;;;249      /* Wait till LSI is ready */
;;;250      while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;251      {
;;;252      }
;;;253    
;;;254      /* Select LSI as RTC Clock Source */
;;;255      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);  
;;;256    #elif defined	RTCClockSource_LSE  
;;;257      /* Enable LSE */
;;;258      RCC_LSEConfig(RCC_LSE_ON);
00017c  2001              MOVS     r0,#1
00017e  f7fffffe          BL       RCC_LSEConfig
;;;259      /* Wait till LSE is ready */
;;;260      while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
000182  bf00              NOP      
                  |L1.388|
000184  2041              MOVS     r0,#0x41
000186  f7fffffe          BL       RCC_GetFlagStatus
00018a  2800              CMP      r0,#0
00018c  d0fa              BEQ      |L1.388|
;;;261      {
;;;262      }
;;;263    
;;;264      /* Select LSE as RTC Clock Source */
;;;265      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);  
00018e  f44f7080          MOV      r0,#0x100
000192  f7fffffe          BL       RCC_RTCCLKConfig
;;;266    #endif
;;;267    
;;;268    
;;;269      /* Enable RTC Clock */
;;;270      RCC_RTCCLKCmd(ENABLE);
000196  2001              MOVS     r0,#1
000198  f7fffffe          BL       RCC_RTCCLKCmd
;;;271    
;;;272    
;;;273    #ifdef RTCClockOutput_Enable  
;;;274      /* Disable the Tamper Pin */
;;;275      BKP_TamperPinCmd(DISABLE); /* To output RTCCLK/64 on Tamper pin, the tamper
;;;276                                   functionality must be disabled */
;;;277                                   
;;;278      /* Enable RTC Clock Output on Tamper Pin */
;;;279      BKP_RTCCalibrationClockOutputCmd(ENABLE);
;;;280    #endif 
;;;281    
;;;282      /* Wait for RTC registers synchronization */
;;;283      RTC_WaitForSynchro();
00019c  f7fffffe          BL       RTC_WaitForSynchro
;;;284    
;;;285      /* Wait until last write operation on RTC registers has finished */
;;;286      RTC_WaitForLastTask();
0001a0  f7fffffe          BL       RTC_WaitForLastTask
;;;287      
;;;288      /* Enable the RTC Second */  
;;;289      RTC_ITConfig(RTC_IT_SEC, ENABLE);
0001a4  2101              MOVS     r1,#1
0001a6  4608              MOV      r0,r1
0001a8  f7fffffe          BL       RTC_ITConfig
;;;290    
;;;291      /* Wait until last write operation on RTC registers has finished */
;;;292      RTC_WaitForLastTask();
0001ac  f7fffffe          BL       RTC_WaitForLastTask
;;;293      
;;;294      /* Set RTC prescaler: set RTC period to 1sec */
;;;295    #ifdef RTCClockSource_LSI
;;;296      RTC_SetPrescaler(31999); /* RTC period = RTCCLK/RTC_PR = (32.000 KHz)/(31999+1) */
;;;297    #elif defined	RTCClockSource_LSE
;;;298      RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
0001b0  f64770ff          MOV      r0,#0x7fff
0001b4  f7fffffe          BL       RTC_SetPrescaler
;;;299    #endif
;;;300      
;;;301      /* Wait until last write operation on RTC registers has finished */
;;;302      RTC_WaitForLastTask();
0001b8  f7fffffe          BL       RTC_WaitForLastTask
;;;303    }
0001bc  bd10              POP      {r4,pc}
;;;304    
                          ENDP

                  USART_Configuration PROC
;;;409    *******************************************************************************/
;;;410    void USART_Configuration(void)
0001be  b500              PUSH     {lr}
;;;411    {
0001c0  b087              SUB      sp,sp,#0x1c
;;;412      USART_InitTypeDef USART_InitStructure;
;;;413      USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;414    /* USART1 configuration -----------------------------------------------
;;;415    
;;;416    -------*/
;;;417      /* USART1 configured as follow:
;;;418            - BaudRate = 115200 baud  
;;;419            - Word Length = 8 Bits
;;;420            - One Stop Bit
;;;421            - No parity
;;;422            - Hardware flow control disabled (RTS and CTS signals)
;;;423            - Receive and transmit enabled
;;;424            - USART Clock disabled
;;;425            - USART CPOL: Clock is active low
;;;426            - USART CPHA: Data is captured on the middle 
;;;427            - USART LastBit: The clock pulse of the last data bit is not 
;;;428    
;;;429    output to 
;;;430                             the SCLK pin
;;;431      */
;;;432    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
0001c2  2000              MOVS     r0,#0
0001c4  f8ad0004          STRH     r0,[sp,#4]
;;;433    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
0001c8  f8ad0006          STRH     r0,[sp,#6]
;;;434    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
0001cc  f44f7000          MOV      r0,#0x200
0001d0  f8ad0008          STRH     r0,[sp,#8]
;;;435    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
0001d4  2000              MOVS     r0,#0
0001d6  f8ad000a          STRH     r0,[sp,#0xa]
;;;436    /* Configure the USART1 synchronous paramters */
;;;437    USART_ClockInit(USART1, &USART_ClockInitStructure);
0001da  a901              ADD      r1,sp,#4
0001dc  4879              LDR      r0,|L1.964|
0001de  f7fffffe          BL       USART_ClockInit
;;;438    
;;;439    USART_InitStructure.USART_BaudRate = 115200;
0001e2  f44f30e1          MOV      r0,#0x1c200
0001e6  9003              STR      r0,[sp,#0xc]
;;;440    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001e8  2000              MOVS     r0,#0
0001ea  f8ad0010          STRH     r0,[sp,#0x10]
;;;441    USART_InitStructure.USART_StopBits = USART_StopBits_1;
0001ee  f8ad0012          STRH     r0,[sp,#0x12]
;;;442    USART_InitStructure.USART_Parity = USART_Parity_No ;
0001f2  f8ad0014          STRH     r0,[sp,#0x14]
;;;443    USART_InitStructure.USART_HardwareFlowControl = 
0001f6  f8ad0018          STRH     r0,[sp,#0x18]
;;;444    
;;;445    USART_HardwareFlowControl_None;
;;;446    
;;;447    
;;;448    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0001fa  200c              MOVS     r0,#0xc
0001fc  f8ad0016          STRH     r0,[sp,#0x16]
;;;449    /* Configure USART1 basic and asynchronous paramters */
;;;450    USART_Init(USART1, &USART_InitStructure);
000200  a903              ADD      r1,sp,#0xc
000202  4870              LDR      r0,|L1.964|
000204  f7fffffe          BL       USART_Init
;;;451        
;;;452      /* Enable USART1 */
;;;453      USART_Cmd(USART1, ENABLE);
000208  2101              MOVS     r1,#1
00020a  486e              LDR      r0,|L1.964|
00020c  f7fffffe          BL       USART_Cmd
;;;454    }
000210  b007              ADD      sp,sp,#0x1c
000212  bd00              POP      {pc}
;;;455    
                          ENDP

                  GPIO_Configuration PROC
;;;206    *******************************************************************************/
;;;207    void GPIO_Configuration(void)
000214  b508              PUSH     {r3,lr}
;;;208    {
;;;209      GPIO_InitTypeDef GPIO_InitStructure;
;;;210        
;;;211      /* Configure PC.06 as output push-pull */
;;;212      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000216  2040              MOVS     r0,#0x40
000218  f8ad0000          STRH     r0,[sp,#0]
;;;213      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00021c  2003              MOVS     r0,#3
00021e  f88d0002          STRB     r0,[sp,#2]
;;;214      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000222  2010              MOVS     r0,#0x10
000224  f88d0003          STRB     r0,[sp,#3]
;;;215      GPIO_Init(GPIOC, &GPIO_InitStructure);
000228  4669              MOV      r1,sp
00022a  4893              LDR      r0,|L1.1144|
00022c  f7fffffe          BL       GPIO_Init
;;;216    
;;;217      /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;218      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000230  f44f7000          MOV      r0,#0x200
000234  f8ad0000          STRH     r0,[sp,#0]
;;;219      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000238  2018              MOVS     r0,#0x18
00023a  f88d0003          STRB     r0,[sp,#3]
;;;220      GPIO_Init(GPIOA, &GPIO_InitStructure);
00023e  4669              MOV      r1,sp
000240  488e              LDR      r0,|L1.1148|
000242  f7fffffe          BL       GPIO_Init
;;;221        
;;;222      /* Configure USART1 Rx (PA.10) as input floating */
;;;223      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000246  f44f6080          MOV      r0,#0x400
00024a  f8ad0000          STRH     r0,[sp,#0]
;;;224      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00024e  2004              MOVS     r0,#4
000250  f88d0003          STRB     r0,[sp,#3]
;;;225      GPIO_Init(GPIOA, &GPIO_InitStructure);
000254  4669              MOV      r1,sp
000256  4889              LDR      r0,|L1.1148|
000258  f7fffffe          BL       GPIO_Init
;;;226    }
00025c  bd08              POP      {r3,pc}
;;;227    
                          ENDP

                  NVIC_Configuration PROC
;;;184    *******************************************************************************/
;;;185    void NVIC_Configuration(void)
00025e  b508              PUSH     {r3,lr}
;;;186    {
;;;187      NVIC_InitTypeDef NVIC_InitStructure;
;;;188      
;;;189      /* Configure one bit for preemption priority */
;;;190      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000260  f44f60c0          MOV      r0,#0x600
000264  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;191      
;;;192      /* Enable the RTC Interrupt */
;;;193      NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQChannel;
000268  2003              MOVS     r0,#3
00026a  f88d0000          STRB     r0,[sp,#0]
;;;194      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00026e  2001              MOVS     r0,#1
000270  f88d0001          STRB     r0,[sp,#1]
;;;195      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000274  2000              MOVS     r0,#0
000276  f88d0002          STRB     r0,[sp,#2]
;;;196      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00027a  2001              MOVS     r0,#1
00027c  f88d0003          STRB     r0,[sp,#3]
;;;197      NVIC_Init(&NVIC_InitStructure);
000280  4668              MOV      r0,sp
000282  f7fffffe          BL       NVIC_Init
;;;198    }
000286  bd08              POP      {r3,pc}
;;;199    
                          ENDP

                  RCC_Configuration PROC
;;;125    *******************************************************************************/
;;;126    void RCC_Configuration(void)
000288  b510              PUSH     {r4,lr}
;;;127    {
;;;128      /* RCC system reset(for debug purpose) */
;;;129      RCC_DeInit();
00028a  f7fffffe          BL       RCC_DeInit
;;;130    
;;;131      /* Enable HSE */
;;;132      RCC_HSEConfig(RCC_HSE_ON);
00028e  f44f3080          MOV      r0,#0x10000
000292  f7fffffe          BL       RCC_HSEConfig
;;;133    
;;;134      /* Wait till HSE is ready */
;;;135      HSEStartUpStatus = RCC_WaitForHSEStartUp();
000296  f7fffffe          BL       RCC_WaitForHSEStartUp
00029a  4979              LDR      r1,|L1.1152|
00029c  7008              STRB     r0,[r1,#0]
;;;136    
;;;137      if(HSEStartUpStatus == SUCCESS)
00029e  4608              MOV      r0,r1
0002a0  7800              LDRB     r0,[r0,#0]  ; HSEStartUpStatus
0002a2  2801              CMP      r0,#1
0002a4  d126              BNE      |L1.756|
;;;138      {
;;;139        /* HCLK = SYSCLK */
;;;140        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
0002a6  2000              MOVS     r0,#0
0002a8  f7fffffe          BL       RCC_HCLKConfig
;;;141      
;;;142        /* PCLK2 = HCLK */
;;;143        RCC_PCLK2Config(RCC_HCLK_Div1); 
0002ac  2000              MOVS     r0,#0
0002ae  f7fffffe          BL       RCC_PCLK2Config
;;;144    
;;;145        /* PCLK1 = HCLK/2 */
;;;146        RCC_PCLK1Config(RCC_HCLK_Div2);
0002b2  f44f6080          MOV      r0,#0x400
0002b6  f7fffffe          BL       RCC_PCLK1Config
;;;147    
;;;148        /* Flash 2 wait state */
;;;149        FLASH_SetLatency(FLASH_Latency_2);
0002ba  2002              MOVS     r0,#2
0002bc  f7fffffe          BL       FLASH_SetLatency
;;;150        /* Enable Prefetch Buffer */
;;;151        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
0002c0  2010              MOVS     r0,#0x10
0002c2  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;152    
;;;153        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;154        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
0002c6  f44f11e0          MOV      r1,#0x1c0000
0002ca  f44f3080          MOV      r0,#0x10000
0002ce  f7fffffe          BL       RCC_PLLConfig
;;;155    
;;;156        /* Enable PLL */ 
;;;157        RCC_PLLCmd(ENABLE);
0002d2  2001              MOVS     r0,#1
0002d4  f7fffffe          BL       RCC_PLLCmd
;;;158    
;;;159        /* Wait till PLL is ready */
;;;160        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
0002d8  bf00              NOP      
                  |L1.730|
0002da  2039              MOVS     r0,#0x39
0002dc  f7fffffe          BL       RCC_GetFlagStatus
0002e0  2800              CMP      r0,#0
0002e2  d0fa              BEQ      |L1.730|
;;;161        {
;;;162        }
;;;163    
;;;164        /* Select PLL as system clock source */
;;;165        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
0002e4  2002              MOVS     r0,#2
0002e6  f7fffffe          BL       RCC_SYSCLKConfig
;;;166    
;;;167        /* Wait till PLL is used as system clock source */
;;;168        while(RCC_GetSYSCLKSource() != 0x08)
0002ea  bf00              NOP      
                  |L1.748|
0002ec  f7fffffe          BL       RCC_GetSYSCLKSource
0002f0  2808              CMP      r0,#8
0002f2  d1fb              BNE      |L1.748|
                  |L1.756|
;;;169        {
;;;170        }
;;;171      }
;;;172    
;;;173      /* Enable USART1, GPIOA and GPIOC clocks */
;;;174      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | 
0002f4  2101              MOVS     r1,#1
0002f6  f2440014          MOV      r0,#0x4014
0002fa  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;175                             RCC_APB2Periph_GPIOC , ENABLE);
;;;176    }
0002fe  bd10              POP      {r4,pc}
;;;177    
                          ENDP

                  main PROC
;;;53     *******************************************************************************/
;;;54     int main(void)
000300  b510              PUSH     {r4,lr}
;;;55     {
;;;56     #ifdef DEBUG
;;;57       debug();
;;;58     #endif
;;;59     
;;;60       /* System Clocks Configuration */
;;;61       RCC_Configuration();
000302  f7fffffe          BL       RCC_Configuration
;;;62      
;;;63       /* NVIC configuration */
;;;64       NVIC_Configuration();
000306  f7fffffe          BL       NVIC_Configuration
;;;65     
;;;66       /* Configure the GPIOs */
;;;67       GPIO_Configuration();
00030a  f7fffffe          BL       GPIO_Configuration
;;;68       
;;;69       /* Configure the USART1 */
;;;70       USART_Configuration();
00030e  f7fffffe          BL       USART_Configuration
;;;71          
;;;72       if(BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)
000312  2004              MOVS     r0,#4
000314  f7fffffe          BL       BKP_ReadBackupRegister
000318  f5a04125          SUB      r1,r0,#0xa500
00031c  39a5              SUBS     r1,r1,#0xa5
00031e  d00f              BEQ      |L1.832|
;;;73       {
;;;74         /* Backup data register value is not correct or not yet programmed (when
;;;75            the first time the program is executed) */
;;;76     
;;;77         printf("\r\n\n RTC not yet configured....");
000320  a058              ADR      r0,|L1.1156|
000322  f7fffffe          BL       __2printf
;;;78        
;;;79         /* RTC Configuration */
;;;80         RTC_Configuration();
000326  f7fffffe          BL       RTC_Configuration
;;;81     
;;;82          printf("\r\n RTC configured....");
00032a  a05e              ADR      r0,|L1.1188|
00032c  f7fffffe          BL       __2printf
;;;83      
;;;84         /* Adjust time by values entred by the user on the hyperterminal */
;;;85         Time_Adjust();
000330  f7fffffe          BL       Time_Adjust
;;;86     
;;;87         BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);    
000334  f24a51a5          MOV      r1,#0xa5a5
000338  2004              MOVS     r0,#4
00033a  f7fffffe          BL       BKP_WriteBackupRegister
00033e  e019              B        |L1.884|
                  |L1.832|
;;;88       }
;;;89       else
;;;90       {
;;;91         /* Check if the Power On Reset flag is set */
;;;92         if(RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
000340  207b              MOVS     r0,#0x7b
000342  f7fffffe          BL       RCC_GetFlagStatus
000346  b118              CBZ      r0,|L1.848|
;;;93         {
;;;94           printf("\r\n\n Power On Reset occurred....");
000348  a05c              ADR      r0,|L1.1212|
00034a  f7fffffe          BL       __2printf
00034e  e006              B        |L1.862|
                  |L1.848|
;;;95         }
;;;96         /* Check if the Pin Reset flag is set */
;;;97         else if(RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
000350  207a              MOVS     r0,#0x7a
000352  f7fffffe          BL       RCC_GetFlagStatus
000356  b110              CBZ      r0,|L1.862|
;;;98         {
;;;99           printf("\r\n\n External Reset occurred....");
000358  a060              ADR      r0,|L1.1244|
00035a  f7fffffe          BL       __2printf
                  |L1.862|
;;;100        }
;;;101    
;;;102        printf("\r\n No need to configure RTC....");    
00035e  a067              ADR      r0,|L1.1276|
000360  f7fffffe          BL       __2printf
;;;103        /* Wait for RTC registers synchronization */
;;;104        RTC_WaitForSynchro();
000364  f7fffffe          BL       RTC_WaitForSynchro
;;;105    
;;;106        /* Enable the RTC Second */  
;;;107        RTC_ITConfig(RTC_IT_SEC, ENABLE);
000368  2101              MOVS     r1,#1
00036a  4608              MOV      r0,r1
00036c  f7fffffe          BL       RTC_ITConfig
;;;108        /* Wait until last write operation on RTC registers has finished */
;;;109        RTC_WaitForLastTask();
000370  f7fffffe          BL       RTC_WaitForLastTask
                  |L1.884|
;;;110      }
;;;111    
;;;112      /* Clear reset flags */
;;;113      RCC_ClearFlag();
000374  f7fffffe          BL       RCC_ClearFlag
;;;114      
;;;115      /* Display time in infinte loop */
;;;116      Time_Show();
000378  f7fffffe          BL       Time_Show
;;;117    }
00037c  2000              MOVS     r0,#0
00037e  bd10              POP      {r4,pc}
;;;118    
                          ENDP

                  fputc PROC
;;;463    
;;;464    int fputc(int ch, FILE *f)
000380  b570              PUSH     {r4-r6,lr}
;;;465    {
000382  4604              MOV      r4,r0
000384  460d              MOV      r5,r1
;;;466    #ifdef DBG_ITM
;;;467    /* 将Printf内容发往ITM激励寄存器端口  */
;;;468      if (DEMCR & TRCENA) {
;;;469        while (ITM_Port32(0) == 0);
;;;470        ITM_Port8(0) = ch;
;;;471      }
;;;472    #else  
;;;473    /* 将Printf内容发往串口 */
;;;474      USART_SendData(USART1, (unsigned char) ch);
000386  b2e1              UXTB     r1,r4
000388  480e              LDR      r0,|L1.964|
00038a  f7fffffe          BL       USART_SendData
;;;475      while (!(USART1->SR & USART_FLAG_TXE));
00038e  bf00              NOP      
                  |L1.912|
000390  480c              LDR      r0,|L1.964|
000392  8800              LDRH     r0,[r0,#0]
000394  f0100f80          TST      r0,#0x80
000398  d0fa              BEQ      |L1.912|
;;;476    #endif  
;;;477      return (ch);
00039a  4620              MOV      r0,r4
;;;478    }
00039c  bd70              POP      {r4-r6,pc}
;;;479    
                          ENDP

00039e  0000              DCW      0x0000
                  |L1.928|
0003a0  54696d653a2025302e32643a25302e32643a25302e32640d00        DCB      "Time: %0.2d:%0.2d:%0.2d\r",0
0003b9  00                DCB      0
0003ba  00                DCB      0
0003bb  00                DCB      0
                  |L1.956|
0003bc  0a0d00            DCB      "\n\r",0
0003bf  00                DCB      0
                  |L1.960|
                          DCD      TimeDisplay
                  |L1.964|
                          DCD      0x40013800
                  |L1.968|
0003c8  0a0d506c6561736520656e7465722076616c6964206e756d626572206265747765656e203020616e64203900        DCB      "\n\rPlease enter valid number between 0 and 9",0
                  |L1.1012|
0003f4  0a0d506c6561736520656e7465722076616c6964206e756d626572206265747765656e203020616e6420256400        DCB      "\n\rPlease enter valid number between 0 and %d",0
000421  00                DCB      0
000422  00                DCB      0
000423  00                DCB      0
                  |L1.1060|
                          DCD      ||.constdata||
                  |L1.1064|
000428  0d0a2020506c656173652053657420486f75727300        DCB      "\r\n  Please Set Hours",0
00043d  00                DCB      0
00043e  00                DCB      0
00043f  00                DCB      0
                  |L1.1088|
000440  3a2020256400        DCB      ":  %d",0
000446  00                DCB      0
000447  00                DCB      0
                  |L1.1096|
000448  0d0a2020506c6561736520536574204d696e7574657300        DCB      "\r\n  Please Set Minutes",0
00045f  00                DCB      0
                  |L1.1120|
000460  0d0a2020506c6561736520536574205365636f6e647300        DCB      "\r\n  Please Set Seconds",0
000477  00                DCB      0
                  |L1.1144|
                          DCD      0x40011000
                  |L1.1148|
                          DCD      0x40010800
                  |L1.1152|
                          DCD      HSEStartUpStatus
                  |L1.1156|
000484  0d0a0a20525443206e6f742079657420636f6e666967757265642e2e2e2e00        DCB      "\r\n\n RTC not yet configured....",0
0004a3  00                DCB      0
                  |L1.1188|
0004a4  0d0a2052544320636f6e666967757265642e2e2e2e00        DCB      "\r\n RTC configured....",0
0004ba  00                DCB      0
0004bb  00                DCB      0
                  |L1.1212|
0004bc  0d0a0a20506f776572204f6e205265736574206f636375727265642e2e2e2e00        DCB      "\r\n\n Power On Reset occurred....",0
                  |L1.1244|
0004dc  0d0a0a2045787465726e616c205265736574206f636375727265642e2e2e2e00        DCB      "\r\n\n External Reset occurred....",0
                  |L1.1276|
0004fc  0d0a204e6f206e65656420746f20636f6e666967757265205254432e2e2e2e00        DCB      "\r\n No need to configure RTC....",0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  0d0a3d3d          DCB      0x0d,0x0a,0x3d,0x3d
000004  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000008  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00000c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000010  54696d65          DCB      0x54,0x69,0x6d,0x65
000014  20536574          DCB      0x20,0x53,0x65,0x74
000018  74696e67          DCB      0x74,0x69,0x6e,0x67
00001c  733d3d3d          DCB      0x73,0x3d,0x3d,0x3d
000020  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000024  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000028  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00002c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000030  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000034  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000038  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00003c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000040  3d3d00            DCB      0x3d,0x3d,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  TimeDisplay
                          DCD      0x00000000
                  HSEStartUpStatus
000004  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
